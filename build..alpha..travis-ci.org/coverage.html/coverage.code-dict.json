{"/home/travis/build/npmtest/node-npmtest-ftpd/test.js":"/* istanbul instrument in package npmtest_ftpd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ftpd/lib.npmtest_ftpd.js":"/* istanbul instrument in package npmtest_ftpd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ftpd = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ftpd = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ftpd/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ftpd && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ftpd */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ftpd\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ftpd.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ftpd.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ftpd.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ftpd.__dirname + '/lib.npmtest_ftpd.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ftpd/node_modules/ftpd/lib/ftpd.js":"var TRACE = false;\n\nvar net = require('net');\nvar util = require('util');\nvar events = require('events');\nvar pathModule = require('path');\nvar fsModule = require('fs');\nvar dateformat = require('dateformat');\n\nvar glob = require('./glob');\nvar starttls = require('./starttls');\n\n/*\n TODO:\n - Implement Full RFC 959\n - Implement Full RFC 2228 [PBSZ and PROT implemented already]\n - Implement RFC 3659\n\n - passive command is for server to determine which port it listens on and report that to the client\n - doesn't necessarily mean it needs to be listening (i guess), but i assume it actually SHOULD be listening\n - it keeps listening for subsequent connections\n\n - what sort of security should i enforce? should i require the same IP for data and control connections?\n - maybe just for milesplit's use?\n */\n\nfunction pathEscape(text) {\n  text = text.replace(/\\\"/g, '\"\"');\n  return text;\n}\n\nfunction withCwd(cwd, path) {\n  var firstChar = (path || '').charAt(0);\n  cwd = cwd || pathModule.sep;\n  path = path || '';\n  if (firstChar === '/' || firstChar === pathModule.sep) {\n    cwd = pathModule.sep;\n  }\n  path = pathModule.join(pathModule.sep, cwd, path);\n  return path;\n}\n\n// Currently used for stripping options from beginning of argument to LIST and NLST.\nfunction stripOptions(str) {\n  var IN_SPACE = 0, IN_DASH = 1;\n  var state = IN_SPACE;\n  for (var i = 0; i < str.length; ++i) {\n    var c = str.charAt(i);\n    if (state == IN_SPACE) {\n      if (c == ' ' || c == '\\t')\n        ;\n      else if (c == '-')\n        state = IN_DASH;\n      else\n        return str.substr(i);\n    }\n    else if (state == IN_DASH && (c == ' ' || c == '\\t')) {\n      state = IN_SPACE;\n    }\n  }\n  return \"\";\n}\n\nfunction PassiveListener() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(PassiveListener, process.EventEmitter);\n\n// We don't want to use setEncoding because it screws up TLS, but we\n// also don't want to explicitly specify ASCII encoding for every call to 'write'\n// with a string argument.\nfunction wwenc(socket, data, callback) {\n  logIf(TRACE, '>> ' + data.trim());\n  return socket.write(data, 'ascii', callback);\n}\n\nfunction FtpServer(host, options) {\n  var self = this;\n  events.EventEmitter.call(self);\n\n  self.host = host;\n\n  self.options = options;\n\n  if (!self.options.maxStatsAtOnce)\n    self.options.maxStatsAtOnce = 5;\n\n  if (!options.getInitialCwd)\n    throw new Error(\"'getInitialCwd' option of FtpServer must be set\");\n  if (!options.getRoot)\n    throw new Error(\"'getRoot' option of FtpServer must be set\");\n  self.getInitialCwd = options.getInitialCwd;\n  self.getRoot = options.getRoot;\n\n  self.getUsernameFromUid = options.getUsernameFromUid || function(uid, c) {\n    c(null, \"ftp\");\n  };\n  self.getGroupFromGid = options.getGroupFromGid || function(gid, c) {\n    c(null, \"ftp\");\n  };\n  self.debugging = options.logLevel || 0;\n  self.useWriteFile = options.useWriteFile;\n  self.useReadFile = options.useReadFile;\n  self.uploadMaxSlurpSize = options.uploadMaxSlurpSize || 0;\n\n  self.server = net.createServer();\n  self.server.on('connection', function(socket) {\n    self._onConnection(socket);\n  });\n  self.server.on('error', function(err) {\n    self.emit('error', err);\n  });\n  self.server.on('close', function() {\n    self.emit('close');\n  });\n}\nutil.inherits(FtpServer, process.EventEmitter);\n\nFtpServer.prototype._onConnection = function(socket) {\n  var conn = new FtpConnection({\n    server: this,\n    socket: socket,\n    pasv: null, // passive listener server\n    dataPort: 20,\n    dataHost: null,\n    dataListener: null, // for incoming passive connections\n    dataSocket: null, // the actual data socket\n    // True if the client has sent a PORT/PASV command, and\n    // we haven't experienced a problem with the configuration\n    // it specified. (This can therefore be true even if there\n    // is not currently an open data connection.)\n    dataConfigured: false,\n    mode: \"ascii\",\n    filefrom: \"\",\n    username: null,\n    filename: \"\",\n    fs: null,\n    cwd: null,\n    root: null,\n    hasQuit: false,\n\n    // State for handling TLS upgrades.\n    secure: false,\n    pbszReceived: false\n  });\n\n  this.emit(\"client:connected\", conn); // pass client info so they can listen for client-specific events\n\n  socket.setTimeout(0);\n  socket.setNoDelay();\n\n  this._logIf(1, \"Connection\");\n  conn.respond(\"220 FTP server (nodeftpd) ready\");\n\n  socket.on('data', function(buf) {\n    conn._onData(buf);\n  });\n  socket.on('end', function() {\n    conn._onEnd();\n  });\n  socket.on('close', function() {\n    conn._onClose();\n  });\n  socket.on('error', function(err) {\n    conn._onError(err);\n  });\n};\n\n[\"listen\", \"close\"].forEach(function(fname) {\n  FtpServer.prototype[fname] = function() {\n    return this.server[fname].apply(this.server, arguments);\n  };\n});\n\nFtpServer.prototype._logIf = function(level, message, conn, isError) {\n  if (this.debugging >= level) {\n    if (conn)\n      console.log((conn & conn.socket ? conn.socket.remoteAddress + \": \" : \"\") + message);\n    else\n      console.log(message);\n\n    if (isError) {\n      console.trace(\"Trace follows\");\n    }\n  }\n};\nFtpServer.prototype._traceIf = function(level, message, conn) {\n  return this._logIf(level, message, conn, true);\n};\n\nfunction FtpConnection(properties) {\n  events.EventEmitter.call(this);\n  for (var k in properties) {\n    this[k] = properties[k];\n  }\n}\nutil.inherits(FtpConnection, process.EventEmitter);\n\nFtpConnection.prototype.respond = function(message, callback) {\n    message += '\\r\\n';\n    return wwenc(this.socket, message, callback);\n};\n\nFtpConnection.prototype._logIf = function(level, message, conn, isError) {\n  return this.server._logIf(level, message, this, isError);\n};\nFtpConnection.prototype._traceIf = function(level, message, conn) {\n  return this.server._traceIf(level, message, this);\n};\n\nFtpConnection.prototype._authenticated = function() {\n  return !!this.username;\n};\n\nFtpConnection.prototype._closeDataConnections = function() {\n  if (this.dataSocket)\n    this.dataSocket.destroy();\n  if (this.pasv)\n    this.pasv.close();\n};\n\nFtpConnection.prototype._createPassiveServer = function() {\n  var self = this;\n\n  return net.createServer(function(psocket) {\n    self._logIf(1, \"Passive data event: connect\");\n\n    if (self.secure) {\n      self._logIf(1, \"Upgrading passive connection to TLS\");\n      starttls.starttlsServer(psocket, self.server.options.tlsOptions, function(err, cleartext) {\n        if (err) {\n          self._logIf(0, \"Error upgrading passive connection to TLS:\" + util.inspect(err));\n          psocket.end();\n          self.dataConfigured = false;\n        }\n        else if (!cleartext.authorized) {\n          if (self.server.options.allowUnauthorizedTls) {\n            self._logIf(0, \"Allowing unauthorized passive connection (allowUnauthorizedTls==true)\");\n            switchToSecure();\n          }\n          else {\n            self._logIf(0, \"Closing unauthorized passive connection (allowUnauthorizedTls==false)\");\n            self.socket.end();\n            self.dataConfigured = false;\n          }\n        }\n        else {\n          switchToSecure();\n        }\n\n        function switchToSecure() {\n          self._logIf(1, \"Secure passive connection started\");\n          self.dataSocket = cleartext;\n          setupPassiveListener();\n        }\n      });\n    }\n    else {\n      self.dataSocket = psocket;\n      setupPassiveListener();\n    }\n\n    function setupPassiveListener() {\n      if (self.dataListener)\n        self.dataListener.emit('ready');\n      else\n        self._logIf(0, \"WARNING: Passive connection initiated, but no data listener\");\n\n      // Responses are not guaranteed to have an 'end' event\n      // (https://github.com/joyent/node/issues/728), but we want to set\n      // dataSocket to null as soon as possible, so we handle both events.\n      self.dataSocket.on('close', allOver('close'));\n      self.dataSocket.on('end', allOver('end'));\n      function allOver(ename) {\n        return function(err) {\n          self._logIf(\n              (err ? 0 : 3),\n              \"Passive data event: \" + ename + (err ? \" due to error\" : \"\")\n          );\n          self.dataSocket = null;\n        };\n      }\n\n      self.dataSocket.on(\"error\", function(err) {\n        self._logIf(0, \"Passive data event: error: \" + err);\n        self.dataSocket = null;\n        self.dataConfigured = false;\n      });\n    }\n  });\n};\n\nFtpConnection.prototype._whenDataReady = function(callback) {\n  var self = this;\n\n  if (self.dataListener) {\n    // how many data connections are allowed?\n    // should still be listening since we created a server, right?\n    if (self.dataSocket) {\n      self._logIf(3, \"A data connection exists\");\n      callback(self.dataSocket);\n    } else {\n      self._logIf(3, \"Currently no data connection; expecting client to connect to pasv server shortly...\");\n      self.dataListener.once('ready', function() {\n        self._logIf(3, \"...client has connected now\");\n        callback(self.dataSocket);\n      });\n    }\n  } else {\n    // Do we need to open the data connection?\n    if (self.dataSocket) { // There really shouldn't be an existing connection\n      self._logIf(3, \"Using existing non-passive dataSocket\");\n      callback(self.dataSocket);\n    } else {\n      self._initiateData(function(sock) {\n        callback(sock);\n      });\n    }\n  }\n};\n\nFtpConnection.prototype._initiateData = function(callback) {\n  var self = this;\n\n  if (self.dataSocket)\n    return callback(self.dataSocket);\n\n  var sock = net.connect(self.dataPort, self.dataHost || self.socket.remoteAddress);\n  sock.on('connect', function() {\n    self.dataSocket = sock;\n    callback(sock);\n  });\n  sock.on('end', allOver);\n  sock.on('close', allOver);\n  function allOver(err) {\n    self.dataSocket = null;\n    self._logIf(err ? 0 : 3, \"Non-passive data connection ended\" + (err ? \"due to error: \" + util.inspect(err) : \"\"));\n  }\n\n  sock.on('error', function(err) {\n    sock.destroy();\n    self._logIf(0, \"Data connection error: \" + util.inspect(err));\n    self.dataSocket = null;\n    self.dataConfigured = false;\n  });\n};\n\nFtpConnection.prototype._onError = function(err) {\n  this._logIf(0, \"Client connection error: \" + util.inspect(err));\n  this.socket.destroy();\n};\n\nFtpConnection.prototype._onEnd = function() {\n  this._logIf(3, \"Client connection ended\");\n};\n\nFtpConnection.prototype._onClose = function() {\n  this._logIf(0, \"Client connection closed\");\n};\n\n// Whitelist of commands which don't require authentication.\n// All other commands sent by unauthorized users will be rejected by default.\nvar DOES_NOT_REQUIRE_AUTH = { };\n[ 'AUTH', 'FEAT', 'NOOP', 'PASS', 'PBSZ', 'PROT', 'QUIT',\n  'TYPE', 'SYST', 'USER'\n].forEach(function(c) {\n      DOES_NOT_REQUIRE_AUTH[c] = true;\n    });\n\n// Commands which can't be issued until a PASV/PORT command has been sent\n// without an intervening data connection error.\nvar REQUIRES_CONFIGURED_DATA = { };\n[ 'LIST', 'NLST', 'RETR', 'STOR' ]\n    .forEach(function(c) {\n      REQUIRES_CONFIGURED_DATA[c] = true;\n    });\n\nFtpConnection.prototype._onData = function(data) {\n  var self = this;\n\n  if (self.hasQuit)\n    return;\n\n  data = data.toString('utf-8').trim();\n  logIf(TRACE, '<< ' + data.trim());\n  // Don't want to include passwords in logs.\n  self._logIf(2, \"FTP command: \" +\n    data.toString('utf-8').replace(/^PASS [\\s\\S]*$/i, 'PASS ***')\n  );\n\n  var command, commandArg;\n  var index = data.indexOf(\" \");\n  if (index > 0) {\n    command = data.substring(0, index).trim().toUpperCase();\n    commandArg = data.substring(index + 1, data.length).trim();\n  } else {\n    command = data.trim().toUpperCase();\n    commandArg = '';\n  }\n\n  var m = '_command_' + command;\n  if (self[m]) {\n    if (DOES_NOT_REQUIRE_AUTH[command]) {\n      self[m](commandArg, command);\n    }\n    else {\n      // If 'tlsOnly' option is set, all commands which require user authentication will only\n      // be permitted over a secure connection. See RFC4217 regarding error code.\n      if (!self.secure && self.server.options.tlsOnly)\n        self.respond(\"522 Protection level not sufficient; send AUTH TLS\");\n      else if (self._authenticated())\n        checkData();\n      else {\n        self.respond('530 Not logged in.');\n      }\n    }\n\n    function checkData() {\n      if (REQUIRES_CONFIGURED_DATA[command] && !self.dataConfigured) {\n        self.respond(\"425 Data connection not configured; send PASV or PORT\");\n        return;\n      }\n\n      self[m](commandArg, command);\n    }\n  }\n  else {\n    self.respond('502 Command not implemented.');\n  }\n  self.previousCommand = command;\n};\n\n/**\n * Specify the user's account (superfluous)\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_ACCT = function () {\n  this.respond('202 Command not implemented, superfluous at this site.');\n  return this;\n};\n\n/**\n * Allocate storage space (superfluous)\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_ALLO = function () {\n  this.respond('202 Command not implemented, superfluous at this site.');\n  return this;\n};\n\nFtpConnection.prototype._command_AUTH = function(commandArg) {\n  var self = this;\n\n  if (!self.server.options.tlsOptions || commandArg != \"TLS\") {\n    return self.respond(\"502 Command not implemented\");\n  }\n\n  self.respond(\"234 Honored\", function() {\n    self._logIf(0, \"Establishing secure connection...\");\n    starttls.starttlsServer(self.socket, self.server.options.tlsOptions, function(err, cleartext) {\n      if (err) {\n        self._logIf(0, \"Error upgrading connection to TLS: \" + util.inspect(err));\n        self.socket.end();\n      }\n      else if (!cleartext.authorized) {\n        self._logIf(0, \"Secure socket not authorized: \" + util.inspect(cleartext.authorizationError));\n        if (self.server.options.allowUnauthorizedTls) {\n          self._logIf(0, \"Allowing unauthorized connection (allowUnauthorizedTls==true)\");\n          switchToSecure();\n        }\n        else {\n          self._logIf(0, \"Closing unauthorized connection (allowUnauthorizedTls==false)\");\n          self.socket.end();\n        }\n      }\n      else {\n        switchToSecure();\n      }\n\n      function switchToSecure() {\n        self._logIf(1, \"Secure connection started\");\n        self.socket = cleartext;\n        self.socket.on('data', function(data) {\n          self._onData(data);\n        });\n        self.secure = true;\n      }\n    });\n  });\n};\n\n/**\n * Change working directory to parent directory\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_CDUP = function () {\n  var pathServer = pathModule.dirname(this.cwd);\n  var pathEscaped = pathEscape(pathServer);\n  this.cwd = pathServer;\n  this.respond('250 Directory changed to \"' + pathEscaped + '\"');\n  return this;\n};\n\n/**\n * Change working directory\n * @param {string} pathRequest\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_CWD = function (pathRequest) {\n  var pathServer = withCwd(this.cwd, pathRequest);\n  var pathFs = pathModule.join(this.root, pathServer);\n  var pathEscaped = pathEscape(pathServer);\n  this.fs.stat(pathFs, function (err, stats) {\n    if (err) {\n      this._logIf(0, 'ERROR: CWD ' + pathRequest + ': ' + err);\n      this.respond(\"550 Directory not found.\");\n    } else if (!stats.isDirectory()) {\n      this._logIf(3, 'Attempt to CWD to non-directory');\n      this.respond('550 Not a directory');\n    } else {\n      this.cwd = pathServer;\n      this.respond('250 CWD successful. \"' + pathEscaped + '\" is current directory');\n    }\n  }.bind(this));\n  return this;\n};\n\nFtpConnection.prototype._command_DELE = function(commandArg) {\n  var self = this;\n\n  var filename = withCwd(self.cwd, commandArg);\n  self.fs.unlink(pathModule.join(self.root, filename), function(err) {\n    if (err) {\n      self._logIf(0, \"Error deleting file: \" + filename + \", \" + err);\n      // write error to socket\n      self.respond(\"550 Permission denied\");\n    } else {\n      self.respond(\"250 File deleted\");\n    }\n  });\n};\n\nFtpConnection.prototype._command_FEAT = function(commandArg) {\n  // Get the feature list implemented by the server. (RFC 2389)\n  this.respond(\n      \"211-Features\\r\\n\" +\n          \" SIZE\\r\\n\" +\n          \" MDTM\\r\\n\" +\n          (!this.server.options.tlsOptions ? \"\" :\n              \" AUTH TLS\\r\\n\" +\n                  \" PBSZ\\r\\n\" +\n                  \" PROT\\r\\n\"\n              ) +\n          \"211 end\"\n  );\n};\n\n/**\n * Print the file modification time\n * @param {string} file\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_MDTM = function (file) {\n  file = withCwd(this.cwd, file);\n  file = pathModule.join(this.root, file);\n  this.fs.stat(file, function (err, stats) {\n    if (err) {\n      this.respond(\"550 File unavailable\");\n    } else {\n      this.respond(\"213 \" + dateformat(stats.mtime, \"yyyymmddhhMMss\"));\n    }\n  }.bind(this));\n  return this;\n};\n\nFtpConnection.prototype._command_LIST = function(commandArg) {\n  this._LIST(commandArg, true/*detailed*/, 'LIST');\n};\nFtpConnection.prototype._command_NLST = function(commandArg) {\n  this._LIST(commandArg, false/*!detailed*/, 'NLST');\n};\n\nFtpConnection.prototype._command_STAT = function(commandArg) {\n  if (commandArg) {\n    this._LIST(commandArg, true/*detailed*/, 'STAT');\n  }\n  else {\n    this.respond(\"211 FTP Server Status OK\");\n  }\n};\n\nFtpConnection.prototype._LIST = function(commandArg, detailed, cmd) {\n  /*\n   Normally the server responds with a mark using code 150. It then stops accepting new connections, attempts to send the contents of the directory over the data connection, and closes the data connection. Finally it\n\n   accepts the LIST or NLST request with code 226 if the entire directory was successfully transmitted;\n   rejects the LIST or NLST request with code 425 if no TCP connection was established;\n   rejects the LIST or NLST request with code 426 if the TCP connection was established but then broken by the client or by network failure; or\n   rejects the LIST or NLST request with code 451 if the server had trouble reading the directory from disk.\n\n   The server may reject the LIST or NLST request (with code 450 or 550) without first responding with a mark. In this case the server does not touch the data connection.\n   */\n\n  var self = this;\n\n  // LIST may be passed options (-a in particular). We just ignore any of these.\n  // (In the particular case of -a, we show hidden files anyway.)\n  var dirname = stripOptions(commandArg);\n  var dir = withCwd(self.cwd, dirname);\n\n  glob.setMaxStatsAtOnce(self.server.options.maxStatsAtOnce);\n  glob.glob(pathModule.join(self.root, dir), self.fs, function(err, files) {\n    if (err) {\n      self._logIf(0, \"While sending file list, reading directory: \" + err);\n      self.respond(\"550 Not a directory\");\n      return;\n    }\n\n    self._logIf(3, \"Directory has \" + files.length + \" files\");\n    if (files.length == 0)\n      return self._listFiles([], detailed, cmd);\n\n    var fileInfos; // To contain list of files with info for each.\n\n    if (!detailed) {\n      // We're not doing a detailed listing, so we don't need to get username\n      // and group name.\n      fileInfos = files;\n      return finished();\n    }\n\n    // Now we need to get username and group name for each file from user/group ids.\n    fileInfos = [];\n\n    var CONC = self.server.options.maxStatsAtOnce;\n    var i = 0, j = 0;\n    for (i = 0; i < files.length && i < CONC; ++i)\n      handleFile(i);\n    j = --i;\n\n    function handleFile(ii) {\n      if (i >= files.length)\n        return i == files.length + j ? finished() : null;\n\n      self.server.getUsernameFromUid(files[ii].stats.uid, function(e1, uname) {\n        self.server.getGroupFromGid(files[ii].stats.gid, function(e2, gname) {\n          if (e1 || e2) {\n            self._logIf(3, \"Error getting user/group name for file: \" + util.inspect(e1 || e2));\n            fileInfos.push({ file: files[ii],\n              uname: null,\n              gname: null });\n          }\n          else {\n            fileInfos.push({ file: files[ii],\n              uname: uname,\n              gname: gname });\n          }\n          handleFile(++i);\n        });\n      });\n    }\n\n    function finished() {\n      // Sort file names.\n      if (!self.server.options.dontSortFilenames) {\n        if (self.server.options.filenameSortMap !== false) {\n          var sm = ( self.server.options.filenameSortMap ||\n              function(x) {\n                return x.toUpperCase();\n              } );\n          for (var i = 0; i < fileInfos.length; ++i)\n            fileInfos[i]._s = sm(detailed ? fileInfos[i].file.name : fileInfos[i].name);\n        }\n\n        var sf = (self.server.options.filenameSortFunc ||\n            function(x, y) {\n              return x.localeCompare(y);\n            });\n        fileInfos = fileInfos.sort(function(x, y) {\n          if (self.server.options.filenameSortMap !== false)\n            return sf(x._s, y._s);\n          else if (detailed)\n            return sf(x.file.name, y.file.name);\n          else\n            return sf(x.name, y.name);\n        });\n      }\n\n      self._listFiles(fileInfos, detailed, cmd);\n    }\n  }, self.server.options.noWildcards);\n};\n\nfunction leftPad(text, width) {\n  var out = '';\n  for (var j = text.length; j < width; j++) out += ' ';\n  out += text;\n  return out;\n}\n\nFtpConnection.prototype._listFiles = function(fileInfos, detailed, cmd) {\n  var self = this;\n\n  var m = \"150 Here comes the directory listing\";\n  var BEGIN_MSGS = { LIST: m, NLST: m,\n                     STAT: \"213-Status follows\" };\n  m = \"226 Transfer OK\";\n  var END_MSGS = { LIST: m, NLST: m,\n                   STAT: \"213 End of status\" };\n\n  self.respond(BEGIN_MSGS[cmd], function() {\n    if (cmd == 'STAT')\n      whenReady(self.socket);\n    else\n      self._whenDataReady(whenReady);\n\n    function whenReady(listconn) {\n      if (fileInfos.length == 0)\n        return success();\n\n      function success(err) {\n        if (err)\n          self.respond(\"550 Error listing files\");\n        else\n          self.respond(END_MSGS[cmd]);\n        if (cmd != 'STAT')\n          listconn.end();\n      }\n\n      self._logIf(3, \"Sending file list\");\n\n      for (var i = 0; i < fileInfos.length; ++i) {\n        var fileInfo = fileInfos[i];\n\n        var line = '';\n\n        if (!detailed) {\n          var file = fileInfo;\n          line += file.name + '\\r\\n';\n        }\n        else {\n          var file = fileInfo.file;\n          var s = file.stats;\n          line += s.isDirectory() ? 'd' : '-';\n          line += (0400 & s.mode) ? 'r' : '-';\n          line += (0200 & s.mode) ? 'w' : '-';\n          line += (0100 & s.mode) ? 'x' : '-';\n          line += (040 & s.mode) ? 'r' : '-';\n          line += (020 & s.mode) ? 'w' : '-';\n          line += (010 & s.mode) ? 'x' : '-';\n          line += (04 & s.mode) ? 'r' : '-';\n          line += (02 & s.mode) ? 'w' : '-';\n          line += (01 & s.mode) ? 'x' : '-';\n          line += \" 1 \" + (fileInfo.uname === null ? \"ftp\" : fileInfo.uname) + \" \" +\n              (fileInfo.gname === null ? \"ftp\" : fileInfo.gname) + \" \";\n          line += leftPad(s.size.toString(), 12) + ' ';\n          var d = new Date(s.mtime);\n          line += leftPad(dateformat(d, 'mmm dd HH:MM'), 12) + ' ';\n          line += file.name;\n          line += '\\r\\n';\n        }\n\n        wwenc(listconn, line, (i == fileInfos.length - 1 ? success : undefined));\n      }\n    }\n  });\n};\n\n/**\n * Create a directory\n * @param {string} pathRequest\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_MKD = function (pathRequest) {\n  var pathServer = withCwd(this.cwd, pathRequest);\n  var pathEscaped = pathEscape(pathServer);\n  var pathFs = pathModule.join(this.root, pathServer);\n  this.fs.mkdir(pathFs, 0755, function (err) {\n    if (err) {\n      this._logIf(0, 'ERROR: MKD ' + pathRequest + ': ' + err);\n      this.respond('550 \"' + pathEscaped + '\" directory NOT created');\n    } else {\n      this.respond('257 \"' + pathEscaped + '\" directory created');\n    }\n  }.bind(this));\n  return this;\n};\n\n/**\n * Perform a no-op (used to keep-alive connection)\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_NOOP = function () {\n  this.respond('200 OK');\n  return this;\n};\n\nFtpConnection.prototype._command_PORT = function(x, y) {\n  this._PORT(x, y);\n};\nFtpConnection.prototype._command_EPRT = function(x, y) {\n  this._PORT(x, y);\n};\nFtpConnection.prototype._PORT = function(commandArg, command) {\n  var self = this;\n\n  self.dataConfigured = false;\n\n  var host, port;\n  if (command == 'PORT') {\n    var m = commandArg.match(/^([0-9]{1,3}),([0-9]{1,3}),([0-9]{1,3}),([0-9]{1,3}),([0-9]{1,3}),([0-9]{1,3})$/);\n    if (!m) {\n      self.respond(\"501 Bad argument to PORT\");\n      return;\n    }\n\n    var host = m[1] + '.' + m[2] + '.' + m[3] + '.' + m[4];\n    var port = (parseInt(m[5]) << 8) + parseInt(m[6]);\n    if (isNaN(port)) {\n      // The value should never be NaN because the relevant groups in the regex matche 1-3 digits.\n      throw new Error(\"Impossible NaN in FtpConnection.prototype._PORT\");\n    }\n  }\n  else { // EPRT\n    if (commandArg.length >= 3 && commandArg.charAt(0) == '|' &&\n        commandArg.charAt(2) == '|' && commandArg.charAt(1) == '2') {\n      // Only IPv4 is supported.\n      self.respond(\"522 Server cannot handle IPv6 EPRT commands, use (1)\");\n      return;\n    }\n\n    var m = commandArg.match(/^\\|1\\|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})\\|([0-9]{1,5})/);\n    if (!m) {\n      self.respond(\"501 Bad Argument to EPRT\");\n      return;\n    }\n\n    var r = parseInt(m[2]);\n    if (isNaN(r)) {\n      // The value should never be NaN because the relevant group in the regex matches 1-5 digits.\n      throw new Error(\"Impossible NaN in FtpConnection.prototype._PORT (2)\");\n    }\n    if (r > 65535 || r <= 0) {\n      self.respond(\"501 Bad argument to EPRT (invalid port number)\");\n      return;\n    }\n\n    host = m[1];\n    port = r;\n  }\n\n  self.dataConfigured = true;\n  self.dataHost = host;\n  self.dataPort = port;\n  self._logIf(3, \"self.dataHost, self.dataPort set to \" + self.dataHost + \":\" + self.dataPort);\n  self.respond(\"200 OK\");\n};\n\nFtpConnection.prototype._command_PASV = function(x, y) {\n  this._PASV(x, y);\n};\nFtpConnection.prototype._command_EPSV = function(x, y) {\n  this._PASV(x, y);\n};\nFtpConnection.prototype._PASV = function(commandArg, command) {\n  var self = this;\n\n  self.dataConfigured = false;\n\n  if (command == \"EPSV\" && commandArg && commandArg != \"1\") {\n    self.respond(\"202 Not supported\");\n    return;\n  }\n\n  // not sure whether the spec limits to 1 data connection at a time ...\n  if (self.dataSocket) {\n    self.dataSocket.end();\n  }\n\n  if (self.dataListener) {\n    self._logIf(3, \"Telling client that they can connect now\");\n    self._writePASVReady(command);\n  }\n  else {\n    self._logIf(3, \"Setting up listener for passive connections\");\n    self._setupNewPASV(commandArg, command);\n  }\n\n  self.dataConfigured = true;\n};\n\nFtpConnection.prototype._writePASVReady = function(command) {\n  var self = this;\n\n  var a = self.pasv.address();\n  var host = self.server.host;\n  var port = a.port;\n  if (command == \"PASV\") {\n    var i1 = (port / 256) | 0;\n    var i2 = port % 256;\n    self.respond(\"227 Entering Passive Mode (\" + host.split(\".\").join(\",\") + \",\" + i1 + \",\" + i2 + \")\");\n  }\n  else { // EPASV\n    self.respond(\"229 Entering Extended Passive Mode (|||\" + port + \"|)\");\n  }\n};\n\nFtpConnection.prototype._setupNewPASV = function(commandArg, command) {\n  var self = this;\n\n  var pasv = self._createPassiveServer();\n  var portRangeErrorHandler;\n\n  function normalErrorHandler(e) {\n    self._logIf(3, \"Error with passive data listener: \" + util.inspect(e));\n    self.respond(\"421 Server was unable to open passive connection listener\");\n    self.dataConfigured = false;\n    self.dataListener = null;\n    self.dataSocket = null;\n    self.pasv = null;\n  }\n\n  if (self.server.options.pasvPortRangeStart != null && self.server.options.pasvPortRangeEnd != null) {\n    // Keep trying ports in the range supplied until either:\n    //     (i)   It works\n    //     (ii)  We get an error that's not just EADDRINUSE\n    //     (iii) We run out of ports to try.\n    var i = self.server.options.pasvPortRangeStart;\n    pasv.listen(i);\n    portRangeErrorHandler = function(e) {\n      if (e.code == 'EADDRINUSE' && i < self.server.options.pasvPortRangeEnd) {\n        pasv.listen(++i);\n      }\n      else {\n        self._logIf(3, \"Passing on error from portRangeErrorHandler to normalErrorHandler:\" + JSON.stringify(e));\n        normalErrorHandler(e);\n      }\n    };\n    pasv.on('error', portRangeErrorHandler);\n  }\n  else {\n    pasv.listen(0);\n    pasv.on('error', normalErrorHandler);\n  }\n\n  // Once we're successfully listening, tell the client\n  pasv.on(\"listening\", function() {\n    self.pasv = pasv;\n\n    if (portRangeErrorHandler) {\n      pasv.removeListener('error', portRangeErrorHandler);\n      pasv.addListener('error', normalErrorHandler);\n    }\n\n    self._logIf(3, \"Passive data connection beginning to listen\");\n\n    var port = pasv.address().port;\n    var host = self.server.host;\n    self.dataListener = new PassiveListener();\n    self._logIf(3, \"Passive data connection listening on port \" + port);\n    self._writePASVReady(command);\n  });\n  pasv.on(\"close\", function() {\n    self.pasv = null;\n    self.dataListener = null;\n    self._logIf(3, \"Passive data listener closed\");\n  });\n};\n\nFtpConnection.prototype._command_PBSZ = function(commandArg) {\n  var self = this;\n\n  if (!self.server.options.tlsOptions)\n    return self.respond(\"202 Not supported\");\n\n  // Protection Buffer Size (RFC 2228)\n  if (!self.secure) {\n    self.respond(\"503 Secure connection not established\");\n  }\n  else if (parseInt(commandArg) != 0) {\n    // RFC 2228 specifies that a 200 reply must be sent specifying a more\n    // satisfactory PBSZ size (0 in our case, since we're using TLS).\n    // Doubt that this will do any good if the client was already confused\n    // enough to send a non-zero value, but ok...\n    self.pbszReceived = true;\n    self.respond(\"200 buffer too big, PBSZ=0\");\n  }\n  else {\n    self.pbszReceived = true;\n    self.respond(\"200 OK\");\n  }\n};\n\nFtpConnection.prototype._command_PROT = function(commandArg) {\n  var self = this;\n\n  if (!self.server.options.tlsOptions)\n    return self.respond(\"202 Not supported\");\n\n  if (!self.pbszReceived) {\n    self.respond(\"503 No PBSZ command received\");\n  }\n  else if (commandArg == 'S' || commandArg == 'E' || commandArg == 'C') {\n    self.respond(\"536 Not supported\");\n  }\n  else if (commandArg == 'P') {\n    self.respond(\"200 OK\");\n  }\n  else {\n    // Don't even recognize this one...\n    self.respond(\"504 Not recognized\");\n  }\n};\n\n/**\n * Print the current working directory.\n * @param {string} commandArg must always be empty\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_PWD = function(commandArg) {\n  var pathEscaped = pathEscape(this.cwd);\n  if (commandArg === '') {\n    this.respond('257 \"' + pathEscaped + '\" is current directory');\n  } else {\n    this.respond('501 Syntax error in parameters or arguments.');\n  }\n  return this;\n};\n\nFtpConnection.prototype._command_QUIT = function(commandArg) {\n  var self = this;\n\n  self.hasQuit = true;\n  self.respond(\"221 Goodbye\", function(err) {\n    if (err)\n      self._logIf(0, \"Error writing 'Goodbye' message following QUIT\");\n    self.socket.end();\n    self._closeDataConnections();\n  });\n};\n\nFtpConnection.prototype._command_RETR = function(commandArg) {\n  var filename = pathModule.join(this.root, withCwd(this.cwd, commandArg));\n\n  if (this.server.options.useReadFile)\n    this._RETR_usingReadFile(commandArg, filename);\n  else\n    this._RETR_usingCreateReadStream(commandArg, filename);\n};\n\nFtpConnection.prototype._RETR_usingCreateReadStream = function(commandArg, filename) {\n  var self = this;\n  var startTime = new Date();\n\n  self.emit(\"file:retr\", \"open\", {\n    user: self.username,\n    file: filename,\n    sTime: startTime\n  });\n\n  function afterOk(callback) {\n    self.respond(\"150 Opening \" + self.mode.toUpperCase() + \" mode data connection\", callback);\n  }\n\n\n  self.fs.open(filename, 'r', function(err, fd){\n    if (err) {\n      self.emit(\"file:retr\", \"error\", {\n        user: self.username,\n        file: filename,\n        filesize: 0,\n        sTime: startTime,\n        eTime: new Date(),\n        duration: new Date() - startTime,\n        errorState: true,\n        error: err\n      });\n      if (err.code == 'ENOENT') {\n        self.respond(\"550 Not Found\");\n      }\n      else { // Who knows what's going on here...\n        self.respond(\"550 Not Accessible\");\n        self._traceIf(0, \"Error at read of '\" + filename + \"' other than ENOENT \" + err, self);\n      }\n    } else {\n      afterOk(function() {\n        self._whenDataReady(function(pasvconn) {\n          var readLength = 0;\n          var now = new Date();\n          var rs = self.fs.createReadStream(null, {fd: fd});\n          rs.pause();\n          rs.once(\"error\", function(err) {\n            self.emit(\"file:retr\", \"close\", {\n              user: self.username,\n              file: filename,\n              filesize: 0,\n              sTime: startTime,\n              eTime: now,\n              duration: now - startTime,\n              errorState: true,\n              error: err\n            });\n          });\n\n          rs.on(\"data\", function(buffer) {\n            readLength += buffer.length;\n          });\n\n          rs.on(\"end\", function(info) {\n            var now = new Date();\n            self.emit(\"file:retr\", \"close\", {\n              user: self.username,\n              file: filename,\n              filesize: 0,\n              sTime: startTime,\n              eTime: now,\n              duration: now - startTime,\n              errorState: false\n            });\n            self.respond(\"226 Closing data connection, sent \" + readLength + \" bytes\");\n          });\n\n          rs.pipe(pasvconn);\n          rs.resume();\n        });\n      });\n    }\n  });\n};\n\nFtpConnection.prototype._RETR_usingReadFile = function(commandArg, filename) {\n  var self = this;\n  var startTime = new Date();\n\n  self.emit(\"file:retr\", \"open\", {\n    user: self.username,\n    file: filename,\n    sTime: startTime\n  });\n\n  function afterOk(callback) {\n    self.respond(\"150 Opening \" + self.mode.toUpperCase() + \" mode data connection\", callback);\n  }\n\n  self.fs.readFile(filename, function(err, contents) {\n    if (err) {\n      self.emit(\"file:retr\", \"error\", {\n        user: self.username,\n        file: filename,\n        filesize: 0,\n        sTime: startTime,\n        eTime: new Date(),\n        duration: new Date() - startTime,\n        errorState: true,\n        error: err\n      });\n      if (err.code == 'ENOENT') {\n        self.respond(\"550 Not Found\");\n      }\n      else { // Who knows what's going on here...\n        self.respond(\"550 Not Accessible\");\n        self._traceIf(0, \"Error at read of '\" + filename + \"' other than ENOENT \" + err, self);\n      }\n    }\n    else {\n      afterOk(function() {\n        self._whenDataReady(function(pasvconn) {\n          contents = {filename: filename, data: contents};\n          self.emit(\"file:retr:contents\", contents);\n          contents = contents.data;\n          pasvconn.write(contents);\n          var contentLength = contents.length;\n          self.respond(\"226 Closing data connection, sent \" + contentLength + \" bytes\");\n          self.emit(\"file:retr\", \"close\", {\n            user: self.username,\n            file: filename,\n            filesize: contentLength,\n            sTime: startTime,\n            eTime: new Date(),\n            duration: new Date() - startTime,\n            errorState: false\n          });\n          pasvconn.end();\n        });\n      });\n    }\n  });\n};\n\n/**\n * Remove a directory\n * @param {string} pathRequest\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_RMD = function (pathRequest) {\n  var pathServer = withCwd(this.cwd, pathRequest);\n  var pathFs = pathModule.join(this.root, pathServer);\n  this.fs.rmdir(pathFs, function (err) {\n    if (err) {\n      this._logIf(0, 'ERROR: RMD ' + pathRequest + ': ' + err);\n      this.respond('550 Delete operation failed');\n    } else {\n      this.respond('250 \"' + pathServer + '\" directory removed');\n    }\n  }.bind(this));\n  return this;\n};\n\nFtpConnection.prototype._command_RNFR = function(commandArg) {\n  var self = this;\n\n  self.filefrom = withCwd(self.cwd, commandArg);\n  self._logIf(3, \"Rename from \" + self.filefrom);\n  self.respond(\"350 Ready for destination name\");\n};\n\nFtpConnection.prototype._command_RNTO = function(commandArg) {\n  var self = this;\n\n  var fileto = withCwd(self.cwd, commandArg);\n  self.fs.rename(pathModule.join(self.root, self.filefrom), pathModule.join(self.root, fileto), function(err) {\n    if (err) {\n      self._logIf(3, \"Error renaming file from \" + self.filefrom + \" to \" + fileto);\n      self.respond(\"550 Rename failed\" + ( err.code == 'ENOENT' ? \"; file does not exist\" : \"\" ));\n    } else {\n      self.respond(\"250 File renamed successfully\");\n    }\n  });\n};\n\nFtpConnection.prototype._command_SIZE = function(commandArg) {\n  var self = this;\n\n  var filename = withCwd(self.cwd, commandArg);\n  self.fs.stat(pathModule.join(self.root, filename), function(err, s) {\n    if (err) {\n      self._traceIf(0, \"Error getting size of file '\" + filename + \"' \", self.socket);\n      self.respond(\"450 Failed to get size of file\");\n      return;\n    }\n    self.respond(\"213 \" + s.size + \"\");\n  });\n};\n\nFtpConnection.prototype._command_TYPE = function(commandArg) {\n  if (commandArg == \"I\" || commandArg == \"A\")\n    this.respond(\"200 OK\");\n  else\n    this.respond(\"202 Not supported\");\n};\n\nFtpConnection.prototype._command_SYST = function(commandArg) {\n  this.respond(\"215 UNIX Type: I\");\n};\n\nFtpConnection.prototype._command_STOR = function(commandArg) {\n  var filename = withCwd(this.cwd, commandArg);\n\n  if (this.server.options.useWriteFile)\n    this._STOR_usingWriteFile(filename);\n  else\n    this._STOR_usingCreateWriteStream(filename);\n};\n\n// 'initialBuffers' argument is set when this is called from _STOR_usingWriteFile.\nFtpConnection.prototype._STOR_usingCreateWriteStream = function(filename, initialBuffers) {\n  var self = this;\n\n  var wStreamFlags = {flags: \"w\", mode: 0644};\n  var storeStream = self.fs.createWriteStream(pathModule.join(self.root, filename), wStreamFlags);\n  var notErr = true;\n  // Adding for event metadata for file upload (STOR)\n  var startTime = new Date();\n  var uploadSize = 0;\n\n  if (initialBuffers) {\n    //todo: handle back-pressure\n    initialBuffers.forEach(function(b) {\n      storeStream.write(b);\n    });\n  }\n\n  self._whenDataReady(handleUpload);\n\n  storeStream.on(\"open\", function(fd) {\n    self._logIf(3, \"File opened/created: \" + filename);\n    self._logIf(3, \"Told client ok to send file data\");\n    // Adding event emitter for upload start time\n    self.emit(\"file:stor\", \"open\", {\n      user: self.username,\n      file: filename,\n      time: startTime\n    });\n\n    self.respond(\"150 Ok to send data\");\n  });\n\n  storeStream.on(\"error\", function(err) {\n    self.emit(\"file:stor\", \"error\", {\n      user: self.username,\n      file: filename,\n      filesize: uploadSize,\n      sTime: startTime,\n      eTime: new Date(),\n      duration: new Date() - startTime,\n      errorState: !notErr\n    });\n    storeStream.destroy();\n    notErr = false;\n    if (self.dataSocket)\n      self.dataSocket.destroy();\n    self.respond(\"426 Connection closed; transfer aborted\");\n  });\n\n  storeStream.on(\"finish\", function() {\n    // Adding event emitter for completed upload.\n    self.emit(\"file:stor\", \"close\", {\n      user: self.username,\n      file: filename,\n      filesize: uploadSize,\n      sTime: startTime,\n      eTime: new Date(),\n      duration: new Date() - startTime,\n      errorState: !notErr\n    });\n    notErr ? self.respond(\"226 Closing data connection\") : true;\n    if (self.dataSocket)\n      self.dataSocket.end();\n  });\n\n  function handleUpload(dataSocket) {\n    var isPaused = false;\n    dataSocket.on('data', function(buff) {\n      var result = storeStream.write(buff);\n      // Handle back-pressure\n      if (result === false) {\n        dataSocket.pause();\n        isPaused = true;\n        storeStream.once('drain', function() {\n          dataSocket.resume();\n          isPaused = false;\n        });\n      }\n    });\n    dataSocket.once('error', function(buf) {\n      notErr = false;\n      storeStream.destroy();\n    });\n    dataSocket.once('finish', function() {\n      if (isPaused) {\n        storeStream.once('drain', function() {\n          storeStream.end();\n        });\n      } else {\n        storeStream.end();\n      }\n    });\n  }\n};\n\nFtpConnection.prototype._STOR_usingWriteFile = function(filename) {\n  var self = this;\n\n  var erroredOut = false;\n  var slurpBuf = new Buffer(1024);\n  var totalBytes = 0;\n  var startTime = new Date();\n\n  self.emit(\"file:stor\", \"open\", {\n    user: self.username,\n    file: filename,\n    time: startTime\n  });\n\n  self.respond(\"150 Ok to send data\", function() {\n    self._whenDataReady(handleUpload);\n  });\n\n  function handleUpload() {\n    self.dataSocket.on('data', dataHandler);\n    self.dataSocket.once('close', closeHandler);\n    self.dataSocket.once('error', errorHandler);\n  }\n\n  function dataHandler(buf) {\n    if (self.server.options.uploadMaxSlurpSize != null &&\n        totalBytes + buf.length > self.server.options.uploadMaxSlurpSize) {\n      // Give up trying to slurp it -- it's too big.\n\n      // If the 'fs' module we've been given doesn't implement 'createWriteStream', then\n      // we give up and send the client an error.\n      if (!self.fs.createWriteStream) {\n        if (self.dataSocket)\n          self.dataSocket.destroy();\n        self.respond(\"552 Requested file action aborted; file too big\");\n        return;\n      }\n\n      // Otherwise, we call _STOR_usingWriteStream, and tell it to prepend the stuff\n      // that we've buffered so far to the file.\n      self._logIf(1, \"uploadMaxSlurpSize exceeded; falling back to createWriteStream\");\n      self._STOR_usingCreateWriteStream(filename, [slurpBuf.slice(0, totalBytes), buf]);\n      self.dataSocket.removeListener('data', dataHandler);\n      self.dataSocket.removeListener('error', errorHandler);\n      self.dataSocket.removeListener('close', closeHandler);\n    }\n    else {\n      if (totalBytes + buf.length > slurpBuf.length) {\n        var newLength = slurpBuf.length * 2;\n        if (newLength < totalBytes + buf.length)\n          newLength = totalBytes + buf.length;\n\n        var newSlurpBuf = new Buffer(newLength);\n        slurpBuf.copy(newSlurpBuf, 0, 0, totalBytes);\n        slurpBuf = newSlurpBuf;\n      }\n      buf.copy(slurpBuf, totalBytes, 0, buf.length);\n      totalBytes += buf.length;\n    }\n  }\n\n  function closeHandler() {\n    if (erroredOut)\n      return;\n\n    var contents = {filename: filename, data: slurpBuf.slice(0, totalBytes)};\n    self.emit(\"file:stor:contents\", contents);\n    self.fs.writeFile(pathModule.join(self.root, filename), contents.data, function(err) {\n      self.emit(\"file:stor\", \"close\", {\n        user: self.username,\n        file: filename,\n        filesize: totalBytes,\n        sTime: startTime,\n        eTime: new Date(),\n        duration: new Date() - startTime,\n        errorState: err ? true : false\n      });\n      if (err) {\n        erroredOut = true;\n        self._logIf(0, \"Error writing file\");\n        if (self.dataSocket)\n          self.dataSocket.destroy();\n        self.respond(\"426 Connection closed; transfer aborted\");\n        return;\n      }\n\n      self.respond(\"226 Closing data connection\");\n      if (self.dataSocket)\n        self.dataSocket.end();\n    });\n  }\n\n  function errorHandler(err) {\n    erroredOut = true;\n  }\n};\n\n/**\n * Specify a username for login\n * @param {string} username\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_USER = function (username) {\n  var self = this;\n\n  if (self.server.options.tlsOnly && !self.secure) {\n    self.respond(\n      \"530 This server does not permit login over \" +\n      \"a non-secure connection; \" +\n      \"connect using FTP-SSL with explicit AUTH TLS\");\n  } else {\n    self.emit('command:user', username,\n        function success() {\n          self.respond('331 User name okay, need password.');\n        },\n        function failure() {\n          self.respond('530 Not logged in.');\n        }\n    );\n  }\n  return this;\n};\n\n/**\n * Specify a password for login\n * @param {string} password\n * @return {FtpConnection} this\n */\nFtpConnection.prototype._command_PASS = function (password) {\n  var self = this;\n\n  if (self.previousCommand !== 'USER') {\n    self.respond('503 Bad sequence of commands.');\n  } else {\n    self.emit('command:pass', password,\n        function success(username, userFsModule) {\n          function panic(error, method) {\n            self._logIf(0, method + ' signaled error ' + util.inspect(error));\n            self.respond('421 Service not available, closing control connection.', function () {\n              self.socket.destroy();\n            });\n          }\n          function setCwd(cwd) {\n            function setRoot(root) {\n              self.root = root;\n              self.fs = userFsModule || fsModule;\n              self.respond('230 User logged in, proceed.');\n            }\n\n            self.cwd = cwd;\n            if (self.server.getRoot.length <= 1) {\n              setRoot(self.server.getRoot(self));\n            }\n            else {\n              self.server.getRoot(self, function (err, root) {\n                if (err) {\n                  panic(err, 'getRoot');\n                }\n                else {\n                  setRoot(root);\n                }\n              });\n            }\n          }\n          self.username = username;\n          if (self.server.getInitialCwd.length <= 1) {\n            setCwd(withCwd(self.server.getInitialCwd(self)));\n          }\n          else {\n            self.server.getInitialCwd(self, function (err, cwd) {\n              if (err) {\n                panic(err, 'getInitialCwd');\n              }\n              else {\n                setCwd(withCwd(cwd));\n              }\n            });\n          }\n        },\n        function failure() {\n          self.respond('530 Not logged in.');\n          self.username = null;\n        }\n    );\n  }\n  return this;\n};\n\nexports.FtpServer = FtpServer;\n\nfunction logIf(condition) {\n  if (condition) {\n    console.error.apply(console, [].slice.call(arguments, 1));\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ftpd/node_modules/ftpd/lib/glob.js":"var PathModule = require('path'),\n    events = require('events'),\n    constants = require('constants');\n\nvar CONC = 5;\nfunction setMaxStatsAtOnce(n) {\n  CONC = n;\n}\n\n// Wildcard directory listing. There is no way that a client should\n// use wildcards in directory names unless they're identifying a\n// unique directory to be listed. So this can be pretty simple.\n\nfunction statList(fsm, list, callback) {\n  if (list.length == 0)\n    return callback(null, []);\n\n  var stats = [];\n  var i = 0, j = 0;\n  for (i = 0; i < list.length && i < CONC; ++i)\n    handleFile(i);\n  j = --i;\n\n  var erroredOut = false;\n\n  function handleFile(ii) {\n    if (erroredOut)\n      return;\n    if (i >= list.length)\n      return i == list.length + j ? finished() : null;\n\n    fsm.stat(list[i], function(err, st) {\n      if (err) {\n        erroredOut = true;\n        callback(err);\n      }\n      else {\n        stats.push({ name: PathModule.basename(list[ii]),\n          stats: st });\n        handleFile(++i);\n      }\n    });\n  }\n\n  function finished() {\n    callback(null, stats);\n  }\n}\n\nfunction matchPattern(pattern, string) {\n  var pi = 0, si = 0;\n  for (; si < string.length && pi < pattern.length; ++si) {\n    var c = string.charAt(si);\n    var pc = pattern.charAt(pi);\n\n    if (pc == '*') {\n      if (pi + 1 == pattern.length) {\n        ;\n      }\n      else if (pattern.charAt(pi + 1) == '*') {\n        --si;\n        ++pi;\n      }\n      else if (pattern.charAt(pi + 1) == '?') {\n        ++pi;\n      }\n      else if (si < string.length - 1 && pattern.charAt(pi + 1) == string.charAt(si)) {\n        pi += 2;\n      }\n    }\n    else if (pc == '?') {\n      ++pi;\n    }\n    else if (pc == c) {\n      ++pi;\n    }\n    else {\n      return false;\n    }\n  }\n\n  return (pi == pattern.length || (pi == pattern.length - 1 && pattern.charAt(pi) == '*')) &&\n      si == string.length;\n}\n\nfunction glob(path, fsm, callback, noWildcards) {\n  var s = path.indexOf('*');\n  var q = path.indexOf('?');\n  var w;\n  for (w = 0; !noWildcards && w < path.length && path.charAt(w) != '*' && path.charAt(w) != '?'; ++w);\n\n  if (w == path.length) { // There are no wildcards.\n    fsm.readdir(path, function(err, contents) {\n      if (err) {\n        if (err.errno == constants.ENOTDIR) {\n          statList(fsm, [path], function(err, list) {\n            if (err)\n              return callback(err);\n            if (list.length != 1)\n              throw new Error(\"Internal error in glob.js\");\n            callback(null, list);\n          });\n        }\n        else if (err.errno == constants.ENOENT) {\n          callback(null, []);\n        }\n        else {\n          callback(err);\n        }\n      }\n      else {\n        statList(fsm, contents.map(function(p) {\n          return PathModule.join(path, p);\n        }), function(err, list) {\n          if (err)\n            callback(err);\n          else\n            callback(null, list);\n        });\n      }\n    });\n\n    return;\n  }\n  else {\n    // Check that there is no '/' after the first wildcard.\n\n    var i;\n    for (i = w; i < path.length; ++i) {\n      if (path.charAt(i) == '/')\n        return callback(null, []);\n    }\n\n    var base = \"\", pattern;\n    for (i = w; i >= 0; --i) {\n      if (path.charAt(i) == '/') {\n        base = path.substr(0, i + 1)\n        break;\n      }\n    }\n    pattern = path.substr(i == 0 ? 0 : i + 1);\n\n    // Remove any leading/trailing slashes which might still\n    // be present if the path contains multiple slashes.\n    for (i = 0; i < pattern.length && pattern.charAt(i) == '/'; ++i);\n    if (i > 0)\n      pattern = pattern.substr(i);\n    for (i = base.length - 1; i > 0 && base.charAt(i) == '/'; --i);\n    if (i != base.length - 1)\n      base = base.substr(0, i + 1);\n\n    // We now have the base path in 'base' (possibly the empty string)\n    // and the wildcard filename pattern in 'pattern'.\n\n    readTheDir(false);\n    function readTheDir(listingSingleDir) {\n      fsm.readdir(base, function(err, contents) {\n        if (err) {\n          if (err.errno == constants.ENOTDIR || err.errno == constants.ENOENT) {\n            callback(null, []);\n          }\n          else {\n            callback(err);\n          }\n        }\n        else {\n          var matches;\n          if (!listingSingleDir)\n            matches = contents.filter(function(n) {\n              return matchPattern(pattern, n);\n            });\n          else\n            matches = contents;\n\n          // Special case. If we have exactly one match, and it's a directory, then list\n          // the contents of that directory. (There's no reason why anyone should want\n          // to identify mutliple directories using wildcards and then list all of their\n          // contents over FTP!)\n          if (!listingSingleDir && matches.length == 1) {\n            var dir = PathModule.join(base, matches[0]);\n            fsm.stat(dir, function(err, st) {\n              if (err)\n                return callback(err);\n\n              if (!st.isDirectory()) {\n                doTheNormalThing();\n              }\n              else {\n                base = dir;\n                readTheDir(/*listingSingleDir=*/true);\n              }\n            });\n          }\n          else {\n            doTheNormalThing();\n          }\n\n          function doTheNormalThing() {\n            statList(fsm, matches.map(function(p) {\n              return PathModule.join(base, p);\n            }), function(err, list) {\n              if (err)\n                callback(err);\n              else\n                callback(null, list);\n            });\n          }\n        }\n      });\n    }\n  }\n}\n\nexports.glob = glob;\nexports.matchPattern = matchPattern;\nexports.setMaxStatsAtOnce = setMaxStatsAtOnce;\n","/home/travis/build/npmtest/node-npmtest-ftpd/node_modules/ftpd/lib/starttls.js":"// Modified slightly from\n// https://github.com/andris9/rai/blob/master/lib/starttls.js\n// (This code is MIT licensed.)\n\n//\n// Target API:\n//\n//  var s = require('net').createStream(25, 'smtp.example.com');\n//  s.on('connect', function() {\n//    require('starttls')(s, options, function() {\n//      if (!s.authorized) {\n//        s.destroy();\n//        return;\n//      }\n//\n//      s.end(\"hello world\\n\");\n//    });\n//  });\n//\n//\n\nvar tls = require('tls'),\n    crypto = require('crypto');\n\n// From Node docs for TLS module.\nvar RECOMMENDED_CIPHERS = 'ECDHE-RSA-AES256-SHA:AES256-SHA:RC4-SHA:RC4:HIGH:!MD5:!aNULL:!EDH:!AESGCM';\n\nfunction starttlsServer(socket, options, callback) {\n  return starttls(socket, options, callback, true);\n}\nfunction starttlsClient(socket, options, callback) {\n  return starttls(socket, options, callback, false);\n}\n\nfunction starttls(socket, options, callback, isServer) {\n  var sslcontext, pair, cleartext;\n\n  var opts = { };\n  for (k in options) {\n    opts[k] = options[k];\n  }\n  if (!opts.ciphers)\n    opts.ciphers = RECOMMENDED_CIPHERS;\n\n  socket.removeAllListeners(\"data\");\n  if (tls.createSecureContext) {\n    sslcontext = tls.createSecureContext(opts);\n  } else {\n    sslcontext = crypto.createCredentials(opts);\n  }\n  pair = tls.createSecurePair(sslcontext, isServer);\n  cleartext = pipe(pair, socket);\n\n  var erroredOut = false;\n  pair.on('secure', function() {\n    if (erroredOut) {\n      pair.end();\n      return;\n    }\n\n    var verifyError = (pair._ssl || pair.ssl).verifyError();\n\n    if (verifyError) {\n      cleartext.authorized = false;\n      cleartext.authorizationError = verifyError;\n    } else {\n      cleartext.authorized = true;\n    }\n\n    callback(null, cleartext);\n  });\n  pair.once('error', function(err) {\n    if (!erroredOut) {\n      erroredOut = true;\n      callback(err);\n    }\n  });\n\n  cleartext._controlReleased = true;\n  pair;\n}\n\nfunction forwardEvents(events, emitterSource, emitterDestination) {\n  var map = [], name, handler;\n\n  for (var i = 0, len = events.length; i < len; i++) {\n    name = events[i];\n\n    handler = forwardEvent.bind(emitterDestination, name);\n\n    map.push(name);\n    emitterSource.on(name, handler);\n  }\n\n  return map;\n}\n\nfunction forwardEvent() {\n  this.emit.apply(this, arguments);\n}\n\nfunction removeEvents(map, emitterSource) {\n  for (var i = 0, len = map.length; i < len; i++) {\n    emitterSource.removeAllListeners(map[i]);\n  }\n}\n\nfunction pipe(pair, socket) {\n  pair.encrypted.pipe(socket);\n  socket.pipe(pair.encrypted);\n\n  pair.fd = socket.fd;\n\n  var cleartext = pair.cleartext;\n\n  cleartext.socket = socket;\n  cleartext.encrypted = pair.encrypted;\n  cleartext.authorized = false;\n\n  function onerror(e) {\n    if (cleartext._controlReleased) {\n      cleartext.emit('error', e);\n    }\n  }\n\n  var map = forwardEvents([\"timeout\", \"end\", \"close\", \"drain\", \"error\"], socket, cleartext);\n\n  function onclose() {\n    socket.removeListener('error', onerror);\n    socket.removeListener('close', onclose);\n    removeEvents(map, socket);\n  }\n\n  socket.on('error', onerror);\n  socket.on('close', onclose);\n\n  return cleartext;\n}\n\nexports.starttlsServer = starttlsServer;\nexports.starttlsClient = starttlsClient;\nexports.RECOMMENDED_CIPHERS = RECOMMENDED_CIPHERS;","/home/travis/build/npmtest/node-npmtest-ftpd/node_modules/ftpd/_.js":"a({\n  getRoot: function(connection, callback) {\n    var rootDir = '/my_home';\n    var rootPath = process.cwd() + '/' + connection.username + '/my_home';\n    fs.exists(rootPath, function(exists) {\n      if (exists) {\n        callback(null, rootDir);\n      } else {\n        fs.mkDir(userDir, function(err) {\n          if (err) {\n            callback(null, '/'); // default to root\n          } else {\n            callback(err, rootDir);\n          }\n        });\n      }\n    });\n  }\n  // If the subdir exists, callback immediately with relative path to that directory\n  // If not, create the directory, and callback relative path to the directory\n  // Stupidly, instead of failing, we apparently want 'worst case' scenario to allow relative root.\n});\n"}